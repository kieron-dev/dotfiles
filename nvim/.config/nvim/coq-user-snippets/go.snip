# Snippets for Go

# variable := assignment
snippet :
abbr v := value
    ${1} := ${0}

# anonymous function
snippet anon
abbr fn := func() { ... }
    ${1:fn} := func() {
        ${2:${VISUAL}}
    }
    ${0}

# append
snippet ap
abbr append(slice, value)
    append(${1:slice}, ${0:value})

# append assignment
snippet ap=
abbr a = append(a, value)
        ${1:slice} = append($1, ${0:value})

# break
snippet br
abbr break
        break

# channel
snippet ch
abbr chan Type
        chan ${0:int}

# case
snippet case
abbr case ...:
        case ${1:value}:
            ${0:${VISUAL}}

# constant
snippet con
abbr const XXX Type = ...
        const ${1:NAME} ${2:Type} = ${0:0}

# constants
snippet cons
abbr const ( ... )
        const (
            ${1:NAME} ${2:Type} = ${3:value}
            ${0}
        )

# constants with iota
snippet iota
abbr const ( ... = iota )
        const (
            ${1:NAME} ${2:Type} = iota
            ${0}
        )

# continue
snippet cn
abbr continue
        continue

# default case
snippet default
abbr default: ...
        default:
            ${0:${VISUAL}}

# defer
snippet df
abbr defer someFunction()
        defer ${1:func}(${2})
        ${0}

snippet def
abbr defer func() { ... }
        defer func() {
            ${0:${VISUAL}}
        }()

# defer recover
snippet defr
abbr defer recover()
    defer func() {
        if err := recover(); err != nil {
            ${0:${VISUAL}}
        }
    }()

# gpl
snippet gpl
    /*
    * This program is free software; you can redistribute it and/or modify
    * it under the terms of the GNU General Public License as published by
    * the Free Software Foundation; either version 2 of the License, or
    * (at your option) any later version.
    *
    * This program is distributed in the hope that it will be useful,
    * but WITHOUT ANY WARRANTY; without even the implied warranty of
    * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    * GNU General Public License for more details.
    *
    * You should have received a copy of the GNU General Public License
    * along with this program; if not, see <http://www.gnu.org/licenses/>.
    *
    * Copyright (C) ${1:Author}, `!v strftime("%Y")`
    */
    ${0}

# import
snippet import
abbr import ( ... )
        import (
            "${1:package}"
        )

# full interface snippet
snippet interface
abbr interface I { ... }
    type ${1:Interface} interface {
        ${2:/* TODO: add methods */}
    }

# if condition
snippet if
abbr if ... { ... }
        if ${1:condition} {
            ${0:${VISUAL}}
        }

# else snippet
snippet else
    else {
        ${0:${VISUAL}}
    }

# if inline error
snippet ife
abbr If with inline error
        if err := ${1:condition}; err != nil {
            ${0:${VISUAL}}
        }

snippet ew
abbr errors.Wrap
        errors.Wrap(${1:err}, "${2:message}")

snippet ewf
abbr errors.Wrapf
        errors.Wrapf(${1:err}, "${2:message %v}", ${3:args...})

# error snippet
snippet errn
abbr Error return !b
    if err != nil {
        return err
    }
    ${0}

snippet errnw
abbr Error return wrap !b
        if err != nil {
            return errors.Wrap(err, "${1:message}")
        }
        ${0}

snippet errnwf
abbr Error return wrapf !b
        if err != nil {
            return errors.Wrapf(err, "${1:message %v}", ${2:args...})
        }
        ${0}

# error log snippet
snippet errl
abbr Error with log.Fatal(err) !b
        if err != nil {
            log.Fatal(err)
        }
        ${0}

# error multiple return
snippet errn,
abbr Error return with two return values !b
        if err != nil {
            return ${1:nil}, ${2:err}
        }
        ${0}

snippet errn,w
abbr Error return wrap with two return values !b
        if err != nil {
            return nil, errors.Wrap(err, "${1:message}")
        }
        ${0}

snippet errn,wf
abbr Error return wrapf with two return values !b
        if err != nil {
            return nil, errors.Wrapf(err, "${1:message %v}", ${2:args...})
        }
        ${0}

# error panic
snippet errp
abbr Error panic !b
        if err != nil {
            panic(${1})
        }
        ${0}

# error test
snippet errt
abbr Error test fatal  !b
        if err != nil {
            t.Fatal(err)
        }
        ${0}

# error handle
snippet errh
abbr Error handle and return !b
        if err != nil {
            ${1}
            return
        }
        ${0}

# # json field tag
# snippet json
# abbr json:key
#         `json:"${1:`!v  Snakecase(matchstr(getline("."), '\w\+'))`}"`

# # yaml field tag
# snippet yaml
# abbr yaml:key
#         `yaml:"${1:`!v  Snakecase(matchstr(getline("."), '\w\+'))`}"`

# fallthrough
snippet ft
abbr fallthrough
        fallthrough

# for loop
snippet for
abbr for ... { ... }
        for ${1} {
            ${0:${VISUAL}}
        }

# for integer loop
snippet fori
abbr for 0..N-1 { ... }
        for ${1:i} := 0; $1 < ${2:N}; $1++ {
            ${0:${VISUAL}}
        }

# for range loop
snippet forr
abbr for k, v := range items { ... }
        for ${2:k}, ${3:v} := range ${1} {
            ${0:${VISUAL}}
        }

snippet forsel
abbr for select
        for {
            select {
                case ${2:${1:result} := }<- ${3:channel}:
                    ${0}
            }
        }

snippet selc
abbr select case !b
        case ${1:${2:var} := }<-${3:channel}:
          ${0}

# # function
# snippet func
# abbr func Function(...) [error] { ... }
#         func ${1:name}(${2:params})${3/(.+)/ /}`!p opening_par(snip, 3)`$3`!p closing_par(snip, 3)` {
#             ${0:${VISUAL}}
#         }

# # Fmt Printf debug
# snippet ff
# abbr fmt.Printf(...)
#         fmt.Printf("$1 = %+v\n", ${1:${VISUAL}})

# # Fmt Printf debug with hash
# snippet ffh
# abbr fmt.Printf(#...) hash
#         fmt.Printf("$1 = %#v\n", ${1:${VISUAL}})

# # Fmt Println debug
# snippet fn
# abbr fmt.Println(...)
#         fmt.Println("${1:${VISUAL}}")

# # Fmt Errorf debug
# snippet fe
# abbr fmt.Errorf(...)
#         fmt.Errorf("${1:${VISUAL}}")

# # Fmt Errorf wrap
# snippet few
# abbr fmt.Errorf(%w, err)
#         fmt.Errorf("${1:message}: %w", ${2:${VISUAL:err}})

# # Fmt Errorf wrap and return
# snippet errnfw
# abbr Error return fmt.Errorf(%w, err) !b
#         if ${1:${VISUAL:err}} != nil {
#             return fmt.Errorf("${2:message}: %w", $1)
#         }

# # log printf
# snippet lf
# abbr log.Printf(...)
#         log.Printf("${1:${VISUAL}} = %+v\n", $1)

# # log println
# snippet ln
# abbr log.Println(...)
#         log.Println("${1:${VISUAL}}")

# make
snippet make
abbr make(Type, size)
        make(${1:[]string}, ${2:0})${0}

# map
snippet map
abbr map[Type]Type
        map[${1:string}]${0:int}

# main()
snippet main
abbr func main() { ... }
        func main() {
            ${0:${VISUAL}}
        }

# # method
# snippet meth
# abbr func (self Type) Method(...) [error] { ... }
#         func (${1:receiver} ${2:type}) ${3:name}(${4:params})${5/(.+)/ /}`!p opening_par(snip, 5)`$5`!p closing_par(snip, 5)` {
#             ${0:${VISUAL}}
#         }

# ok
snippet ok
abbr if !ok { ... }
        if !ok {
            ${0:${VISUAL}}
        }

# package
snippet package
abbr package ...
        // Package $1 provides ${2:...}
        package ${1:main}
        ${0}

# panic
snippet pn
abbr panic()
        panic("${0:msg}")

# return
snippet rt
abbr return
        return ${0:${VISUAL}}

# select
snippet select
abbr select { case a := <-chan: ... }
        select {
        case ${1:v1} := <-${2:chan1}:
            ${0}
        }

# struct
snippet st
abbr type T struct { ... }
        type ${1:Type} struct {
            ${0}
        }

# switch
snippet switch
abbr switch x { ... }
        switch ${1:var} {
        case ${2:value1}:
            ${0}
        }

snippet tswitch
abbr type switch x { ... }
        switch ${2:$1 := }${1:v}.(type) {
            ${0}
        }

# sprintf
snippet sp
abbr fmt.Sprintf(...)
        fmt.Sprintf("%${1:s}", ${2:var})

# goroutine named function
snippet go
abbr go someFunc(...)
        go ${1:funcName}(${0})

# goroutine anonymous function
snippet gof
abbr go func() { ... }()
        go func() {
            ${1:${VISUAL}}
        }()
        ${0}

# test function
snippet test
abbr func TestXYZ(t *testing.T) { ... }
        func Test${1:Function}(t *testing.T) {
            ${0:${VISUAL}}
        }

# test table snippet
snippet tt
    var tests = []struct {
        name string
        expected string
        given string
    }{
        {"${1}", "${2}", "${3}",},
    }
    for _, tt := range tests {
        tt := tt
        t.Run(tt.name, func(t *testing.T){
            actual := ${0:${VISUAL}}(tt.given)
            if actual != tt.expected {
                    t.Errorf("$0(%s): expected %s, actual %s", tt.given, tt.expected, actual)
            }

        })
    }


snippet hf
abbr http.HandlerFunc
        func ${1:handler}(w http.ResponseWriter, r *http.Request) {
            ${0:fmt.Fprintf(w, "hello world")}
        }

snippet hhf
abbr mux.HandleFunc !b
        ${1:http}.HandleFunc("${2:/}", func(w http.ResponseWriter, r *http.Request) {
            ${0:fmt.Fprintf(w, "hello world")}
        })

# quick test server
snippet tsrv
abbr httptest.NewServer
        ts := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            fmt.Fprintln(w, ${1:`response`})
        }))
        defer ts.Close()

        ${0:someUrl} = ts.URL

# test error handling
snippet ter
abbr if err != nil { t.Errorf(...) }
        if err != nil {
            t.Errorf("${0:message}")
        }

# test fatal error
snippet terf
abbr if err != nil { t.Fatalf(...) }
        if err != nil {
            t.Fatalf("${0:message}")
        }

snippet example
abbr func ExampleXYZ() { ... }
        func Example${1:Method}() {
            ${0:${VISUAL}}
            // Output:
        }

snippet benchmark
abbr func BenchmarkXYZ(b *testing.B) { ... }
        func Benchmark${1:Method}(b *testing.B) {
            for i := 0; i < b.N; i++ {
                ${0:${VISUAL}}
            }
        }

# variable declaration
snippet var
abbr var x Type [= ...]
        var ${1:x} ${2:Type}${3: = ${0:value}}

# variables declaration
snippet vars
abbr var ( ... )
        var (
            ${1:x} ${2:Type}${3: = ${0:value}}
        )

# # equals fails the test if exp is not equal to act.
# snippet eq
# abbr equals: test two identifiers with DeepEqual
#         if !reflect.DeepEqual(${1:expected}, ${2:actual}) {
#             _, file, line, _ := runtime.Caller(0)
#             fmt.Printf("%s:%d:\n\n\texp: %#v\n\n\tgot: %#v\n\n", filepath.Base(file), line, $1, $2)
#             t.FailNow()
#         }


snippet println
abbr fmt.Println(...)
        fmt.Println(${0:${VISUAL}})

snippet printf
abbr fmt.Printf(format, ...)
        fmt.Printf("${1:%s}", ${0:${VISUAL}})

snippet iferr
abbr if err != nil {...}
        if err != nil {
            ${0}
        }

snippet desc
abbr Ginkgo Describe b
        Describe("${1:something}", func() {
            ${0}
        })

snippet cont
abbr Ginkgo Context b
        Context("${1:something}", func() {
            ${0}
        })

snippet when
abbr Ginkgo When b
        When("${1:something}", func() {
            ${0}
        })

snippet bef
abbr Ginkgo BeforeEach b
        BeforeEach(func() {
            ${0}
        })

snippet aft
abbr Ginkgo AfterEach b
        AfterEach(func() {
            ${0}
        })

snippet just
abbr Ginkgo JustBeforeEach b
        JustBeforeEach(func() {
            ${0}
        })

snippet it
abbr Ginkgo It b
        It("${1:does something}", func() {
            ${0}
        })

snippet exto
abbr Gomega Expect(...).To(...) b
        Expect(${1:actual}).To(${0:${VISUAL}})

snippet exnt
abbr Gomega Expect(...).NotTo(...) b
        Expect(${1:actual}).NotTo(${0:${VISUAL}})

snippet extn
abbr Gomega Expect(...).ToNot(...) b
        Expect(${1:actual}).ToNot(${0:${VISUAL}})

snippet exeo
abbr Gomega Expect(err).To(HaveOccurred()) b
        Expect(err).To(HaveOccurred())

snippet exen
abbr Gomega Expect(err).NotTo(HaveOccurred()) b
        Expect(err).NotTo(HaveOccurred())

# vim:ft=
